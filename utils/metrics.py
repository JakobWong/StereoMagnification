import tensorflow as tf
import numpy as np

def log10(t):
    """
    Calculates the base-10 log of each element in t.

    @param t: The tensor from which to calculate the base-10 log.

    @return: A tensor with the base-10 log of each element in t.
    """

    numerator = tf.log(t)
    denominator = tf.log(tf.constant(10, dtype=numerator.dtype))
    return numerator / denominator

##
# Error calculation
##

# TODO: Add SSIM error http://www.cns.nyu.edu/pub/eero/wang03-reprint.pdf
# TODO: Unit test error functions.

def psnr(y_pred, y_true):
    """
    Computes the Peak Signal to Noise Ratio error between the generated images and the ground
    truth images.

    @param y_pred: A tensor of shape [batch_size, height, width, 3]. The frames generated by the
                       generator model.
    @param y_true: A tensor of shape [batch_size, height, width, 3]. The ground-truth frames for
                      each frame in gen_frames.

    @return: A scalar tensor. The mean Peak Signal to Noise Ratio error over each frame in the
             batch.
    """
    shape = tf.shape(y_pred)
    num_pixels = tf.to_float(shape[1] * shape[2] * shape[3])
    square_diff = tf.square(y_true - y_pred)

    batch_errors = 10 * log10(1 / ((1 / num_pixels) * tf.reduce_sum(square_diff, [1, 2, 3])))
    return tf.reduce_mean(batch_errors)

def sharp_diff(y_pred, y_true):
    """
    Computes the Sharpness Difference error between the generated images and the ground truth
    images.

    @param y_pred: A tensor of shape [batch_size, height, width, 3]. The frames generated by the
                       generator model.
    @param y_true: A tensor of shape [batch_size, height, width, 3]. The ground-truth frames for
                      each frame in gen_frames.

    @return: A scalar tensor. The Sharpness Difference error over each frame in the batch.
    """
    shape = tf.shape(y_pred)
    num_pixels = tf.to_float(shape[1] * shape[2] * shape[3])

    # gradient difference
    # create filters [-1, 1] and [[1],[-1]] for diffing to the left and down respectively.
    # TODO: Could this be simplified with one filter [[-1, 2], [0, -1]]?
    pos = tf.constant(np.identity(3), dtype=tf.float32)
    neg = -1 * pos
    filter_x = tf.expand_dims(tf.stack([neg, pos]), 0)  # [-1, 1]
    filter_y = tf.stack([tf.expand_dims(pos, 0), tf.expand_dims(neg, 0)])  # [[1],[-1]]
    strides = [1, 1, 1, 1]  # stride of (1, 1)
    padding = 'SAME'

    gen_dx = tf.abs(tf.nn.conv2d(y_pred, filter_x, strides, padding=padding))
    gen_dy = tf.abs(tf.nn.conv2d(y_pred, filter_y, strides, padding=padding))
    gt_dx = tf.abs(tf.nn.conv2d(y_true, filter_x, strides, padding=padding))
    gt_dy = tf.abs(tf.nn.conv2d(y_true, filter_y, strides, padding=padding))

    gen_grad_sum = gen_dx + gen_dy
    gt_grad_sum = gt_dx + gt_dy

    grad_diff = tf.abs(gt_grad_sum - gen_grad_sum)

    batch_errors = 10 * log10(1 / ((1 / num_pixels) * tf.reduce_sum(grad_diff, [1, 2, 3])))
    return tf.reduce_mean(batch_errors)

def ssim(y_pred,y_true):
    pred_yuv = tf.image.rgb_to_yuv(y_pred)
    true_yuv = tf.image.rgb_to_yuv(y_true)
    return tf.reduce_mean(tf.image.ssim(pred_yuv, true_yuv, max_val=1.0))